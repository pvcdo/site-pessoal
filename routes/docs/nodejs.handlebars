<div id="topo"></div>

<div class="botoes-mov">

    <a href="#topo">
        <button class="botao-mov">
            <i class="fas fa-angle-double-up fa-2x"></i>
        </button>
    </a>

    <a href="#fim">
        <button class="botao-mov">
            <i class="fas fa-angle-double-down fa-2x"></i>
        </button>
    </a>

</div>

<div id='container'>
    <aside>
        <a class='home' href="/">
            Paulo Oliveira
        </a>
        <hr>
        <h2>Node.js</h2>
        <a href="#express">Express</a>
    </aside>

    <main>

        <h1 id="notas-de-aula">Notas de aula</h1>

        <p>Os códigos de exercícios, tarefas e estudos extras estão no <a
            href="https://github.com/pvcdo/estudos-nodejs">Github</a>.
        </p>

        <h2 id="se-o-1-introdu-o"><span style="color:green"><i class="fab fa-node-js"></i> </span>Seção 1 - Introdução
        </h2>

        <h3 id="1-3-o-que-o-nodejs-">1.3 - O que é o NodeJS?</h3>

        <p>O nodeJS é uma biblioteca utilizada por um compilador, transformando um texto JavaScript em uma linguagem de
            baixo nível.</p>

        <p>O compilador é o V8 engine do Google que transforma o JS em C++. Linguagens de alto nível são mais pesadas
            para rodar, ao transformar o JS em C++ ganha-se em performance.</p>

        <h3 id="1-4-o-que-o-npm-">1.4 - O que é o NPM?</h3>

        <p>O npm é o gerenciador de pacotes do node (e também de outras bibliotecas javascript, como o react), ou seja,
            vai nos permitir baixar bibliotecas de terceiros ou aquelas não nativas que vão nos auxiliar.</p>

        <p>Também alguns comandos são disparados a partir do npm, ou seja, executar scripts.</p>

        <h3 id="1-8-cmder">1.8 - Cmder</h3>

        <p>É um cmd que simula o do Linux, com os mesmos comandos desse, o que trás uma gama de conhecimentos
            interessante para quem quer atuar na área de programação, uma vez que muitos serviços são baseados em linux.
            Outro ponto é que programas, como o docker, precisam de comandos que rodam melhor em um ambiente dessa
            forma.</p>

        <h3 id="1-10-executando-o-primeiro-programa">1.10 - Executando o primeiro programa</h3>

        <p>Os programas são salvos com a extensão ".js". Para executar o comando nós podemos executar via terminal o
            comando &gt;&gt; node &lt;&lt; dentro da pasta onde criamos o programa e passar o nome do arquivo.</p>

        <h3 id="1-11-utilizando-um-m-dulo">1.11 - Utilizando um módulo</h3>

        <p>Módulos são como classes que contém funções e variáveis para executarmos com o Node. Podemos usar módulos que
            já são disponibilizados pelo próprio node na sua intalação (módulos core); módulos de terceiros (baixados) e
            nossos próprios.</p>

        <p>Para usar módulos nós devemos dar um comando de importação (import ou require). O require é mais antigo que o
            import.</p>

        <h3 id="tarefa">TAREFA</h3>

        <p><a href="https://github.com/pvcdo/estudos-nodejs/tree/main/1_INTRO/tarefa">Github</a></p>

        <h2 id="fundamentos-node"><span style="color:green"><i class="fab fa-node-js"></i> </span>Seção 2 -
            Fundamentos de Node.js</h2>

        <h3 id="2-18-o-que-s-o-m-dulos">2.18 - O que são módulos</h3>

        <p>São conjuntos de variáveis e funções (scripts) reaproveitáveis, ou seja, que podemos importar de algum lugar
            e usar no nosso código.</p>

        <ul>
            <li>Internos - aqueles que nós desenvolvemos</li>
            <li>Core modules - vem com a instalação do node.js</li>
            <li>Externos - aqueles que instalamos via npm</li>
        </ul>

        <h4 id="2-19-m-dulos-internos">2.19 - Módulos internos</h4>

        <p><a href="https://github.com/pvcdo/estudos-nodejs/tree/main/2_FUNDAMENTOS/1_modulo_interno">Github</a></p>

        <h3 id="2-20-import-e-export">2.20 - Import e export</h3>

        <p>É a mesma coisa do export default e import do React. Para usarmos essa sintaxe, porém, o arquivo deve ser de
            extensão <b style="color: green">.msj</b></p>

        <p>[GitHub]</p>

        <p>Até o momento da gravação da aula o padrão é o uso do require (importação) e module.exports (exportação)</p>

        <h3 id="2-22-lendo-argumentos-da-linha-de-comandos">2.22 - Lendo argumentos da linha de comandos</h3>

        <p>Pode ser passado um ou mais argumentos na linha de comandos, logo após a solicitação de execução de um
            script. Esses argumentos são armazenados em um array nativo do node e que não precisa ser importado, esse
            array é o process.argv.</p>

        <h4 id="2-23-m-dulos-externos">2.23 - Módulos externos</h4>

        <p>Para instalar módulos externos nós temos que dar o comando >> npm init << para gerarmos o mapeamento dos
                módulos e criar a pasta node_modules, onde serão instalados os módulos baixados.</p>

                <p>Ao dar o comando npm init o sistema nos pergunta alguns dados para a criação do node_modules.</p>

                <p>Os módulos externos ajudam a executar mais facilmente coisas que nós poderíamos demorar muito para
                    fazer.</p>

                <h3>Explorando o console</h3>

                <p>Não existe apenas o .log no console.</p>

                <p><a href=''>GitHub</a> -> 2-7-explorando-console</p>

                <h3>Chalk</h3>

                <p>É um módulo para estilizar console.log</p>

                <a href="https://www.npmjs.com/package/chalk">NPM</a>

                <h3>Lendo input de dados</h3>

                <p>Neste caso podemos usar o método core "readline" e seu método question</p>

                <a href="">GitHub - 2-9-readline</a>

                <h4 id="inquirer">Módulo externo - Inquirer</h4>

                <p>O professor promete ser um método mais fácil que o readline para gerar questionamentos ao usuário
                    pela linha de comandos.</p>

                <p><a href="https://www.npmjs.com/package/inquirer">NPM</a></p>

                <h3 id="event_emitter">Event emitter</h3>

                <p>É uma classe do módulo events (que é um core module) e se comporta como os eventos do navegador
                    (click, onkeydown, onkeyup, onmousedown, etc...), são gatilhos no script.</p>

                <p><a href="#event_emitter">Github</a></p>

                <h3>Códigos Síncronos e assíncronos</h3>

                <p>Esses termos se referem à ordem de execução dos métodos e funções declarados no nosso script. Se
                    temos um método síncrono nós estamos indicando que ele deve ser finalizado antes de que o próximo
                    método seja executado.</p>

                <p>Já um método assíncrono permite que o resto do código seja executado enquanto esse método não tem
                    concluída a sua resposta.</p>

                <h3>Erros no node</h3>

                <p> Podemos usar o comando <b>throw</b>, que vai encerrar a execução do código e indicar o erro através
                    da instância de um objeto Error; ou pedemos usar os blocos try...catch que vai tentar executar um
                    código no try, que caso não passe irá ser criado um objeto de erro que poderá ser tratado no catch
                    como um objeto.</p>

                <h2 id="core-modules"><span style="color:green"><i class="fab fa-node-js"></i> </span>Seção 3 - Core Modules</h2>

                <h3 id="core_modules_introducao">Introdução</h3>

                <p>Alguns core modules fundamentais são</p>

                <ul>
                    <li>
                        <b>http</b> - Usado para criar servidores http, ou seja, receber e retornar requisições e
                        respostas
                    </li>
                    <li>
                        <b>path</b> - extrair caminho até algum arquivo, extensão entre outros
                    </li>
                    <li>
                        <b>fs</b> - leitura e escrita de arquivos e diretórios
                    </li>
                    <li>
                        <b>url</b>
                    </li>
                </ul>

                <h3>Método http</h3>

                <p>Podemos receber uma requisição e responder um html, por exemplo. Ou então podemos criar um servidor e
                    determinar as postas.</p>

                <p><a href="">Github - 3_CORE_MODULES/1-http e 3_CORE_MODULES/2-retornando-html</a></p>

                <h3>Método url</h3>

                <p><a href="">GitHub - 3_CORE_MODULES\3-url e 4-http+url </a></p>

                <h3>Método fs</h3>

                <p><a href="#">GitHub - 6-escrevendo-arquivos</a></p>

                <h4>Escrevendo arquivo</h4>

                <p>fs.writeFile('arquivo.extensão',"algo a ser escrito no arquivo', função callback(erro,&lt conteúdo do
                    arquivo &gt){})</p>

                <p>Esse método substitui tudo que por ventura estivesse escrito anteriormente no arquivo</p>

                <h4>Atualizando arquivo</h4>

                <p>fs.appendFile('arquivo.extensão',"algo a ser escrito no arquivo', função callback(erro,&lt conteúdo
                    do arquivo &gt){})</p>

                <p>Essa função não substitui o que estava escrito anteriormente no arquivo, mas adiciona mais texto ou
                    informações</p>

                <h4>Removendo arquivo</h4>

                <p>fs.unlink('arquivo.extensão',funcao de erro(erro)){}</p>

                <p>É importante colocar uma lógica verificando se existe erro, sob risco do comportamento do programa
                    ser equivocado. Será emitido um erro caso não exista o arquivo que está se tentando excluir.</p>

                <h4>Renomeando arquivo</h4>

                <p>fs.rename('nome antigo', 'nome novo', função callback(erro){})</p>

                <h4>Rotas com Node.js puro</h4>

                <p><a href="#">Github - 10-roteamento</a></p>

                <h4>Stat - detalhes de um arquivo</h4>

                <p><a href="#">Github - 11-detalhes-arquivos</a></p>

                <h3>Módulo path</h3>

                <b style="color: red;">Consultei a <a target="_blank"
                        href="https://nodejs.org/docs/latest-v14.x/api/path.html">documentação do node (versão 14
                        lts)</a> e não achei alguns dos comandos aqui estudados...</b>


                <h4>dirname, basename, extname</h4>

                <p><a href="#">Github - 12-path</a></p>

                <h4>path absoluto (resolve) e formar path (join)</h4>

                <p><a href="#">Github - 13-path-absoluto-join</a></p>

                <h4>existsSync e mkdirSync</h4>

                <p>fs.existsSync('pasta com caminho relativo') &rarr true se a pasta existe</p>

                <p>fs.mkdirSync('nome') &rarr cria a pasta com o nome especificado no diretório local</p>

                <h3>Módulo os</h3>

                <p>Informações do sistema operacional</p>

                <h2><span style="color:green"><i class="fab fa-node-js"></i> </span>Fundamentos do npm</h2>

                <h3>O que é o npm?</h3>

                <p>É o principal gerenciador de pacotes do node.js. Assim como ele tem o yarn também. Com ele nós
                    instalamos módulos externos para o nosso projeto. Nós podemos criar um projeto node sem usar o npm,
                    porém nós gastaríamos mais tempo para criar módulos sem segurança e eficiência.</p>

                <p>Toda criação de um projeto com npm gera um arquivo package.json, que informa quais foram as
                    dependências instaladas entre outras configurações.</p>

                <h3>Criando um projeto</h3>

                <p>Para iniciar o projeto damos o comando &lt; npm init &gt; </p>

                <p>Outra forma de iniciar um projeto node é dar um &lt; npm init -y &gt;, com esse comando são dadas as
                    respostas padrão que o npm init exige.</p>

                <p>Quando nós instalamos o primeiro pacote é criada a pasta node_modules, que é onde os pacotes
                    (dependências) terceiros ficarão armazenados </p>

                <p>Sempre quando formos rodar projetos baixados de outras pessoas temos que dar o comando npm install
                    (npm i) que vai ler o package.json daquele projeto e instalar na nossa máquina os pacotes
                    necessários para o projeto funcionar.</p>

                <h3>Instalando pacote como dev</h3>

                <p>Nós podemos instalar os pacotes para funcionarem apenas no momento que estamos desenvolvendo o nosso
                    projeto (esses pacotes não sobem quando nós formos publicar o projeto). Para isso nos damos o
                    comando <b> npm install --save-dev &lt; pacote &gt;</b>. Dessa forma, no package.json o pacote salvo
                    como dev estará agrupado no atributo devDependencies.</p>

                <h3>Criando scripts</h3>

                <p>Scripts são séries de comandos configurados por nós para serem executados.</p>

                <p>Para criar um script nós vamos no package.json e dentro de "scripts" nós escrevemos o nome comando
                    como atributo e o valor é o que será executado no terminal. Depois nós abrimos o terminal no
                    diretório do projeto e damos o comando <b>npm run "nome-do-script"</b></p>

                <p>Por exemplo: ao dar o comando <b>npm run start</b> no diretório 5-scripts é executado o script start
                    que está especificado no package.json do diretório (que no caso é executar <b>node index.js</b>)</p>

                <p>Colocando o nome do script como start, nós não precisamos escrever run bastando apenas escrever
                    <b>npm start</b>. Isso também acontece com alguns outros poucos scripts especiais (como test).</p>

                <h3>Pacotes globais</h3>

                <p>Nós podemos instalar um pacote de forma que ele fique na raiz do node do nosso pc e seja acessível a
                    qualquer projeto dentro do nosso pc.</p>

                <p>Ele não gera, portanto uma inclusão no node_modules local, nem aparece no package.json.</p>

                <p>Alguns pacotes precisam ter suas pastas instaladas localmente e para acessar este tipo de pacote (que
                    precisa de suas pastas por perto) mas que foi instalado globalmente, nós podemos usar o comando
                    <b>npm link "nome_do_pacote_global"</b> </p>

                <p>Para isso nós damos o comando <b>npm install -g "nome_do_pacote"</b></p>

                <h3>NPX</h3>

                <b style="color:green">O npx é um executador de pacotes npm, ele instala e roda um pacote.</b>

                <P>Nós usamos esse comando para trabalhar com pacotes de scripts executáveis (como é o caso do
                    create-react-app).</P>

                <h3>Remover pacotes</h3>

                <b>npm uninstall "nome_do_pacote"</b>

                <p>Ele também é removido do package.json.</p>

                <hr style="border-top: 2px green dashed; color:white">

                <h2><span style="color:green"><i class="fab fa-node-js"></i> </span>Projeto Account</h2>

                <a href="5_PROJ_ACCOUNTS">GitHub - 5_PROJ_ACCOUNTS</a>

                <h3>Setup inicial</h3>

                <p>O professor instalou chalk e inquirer.</p>

                <hr style="border-top: 2px green dashed; color:white">

                <h2 id="express"><span style="color:green"><i class="fab fa-node-js"></i> </span>Seção 6 - Introdução ao Express</h2>

                <p>Framework para back-end para nodejs. Podemos criar API's e page reloaders.</p>

                <h3>O que é o Express?</h3>

                <p>Serve para agilizarmos a criação de aplicações web, desde renderizações html com integração com
                    bancos de dados e rotas com o nodeJS.</p>

                <p>Ele é um pacote npm e sua instalação é <b>npm i express</b>. Antes de instalá-lo, temos que iniciar o
                    npm no diretório do nosso projeto em express</p>

                <h3>Rotas em Express</h3>

                <p>As rotas são as url's que nós acessamos. Estão presentes depois da barra, no fim do domínio. A rota
                    raiz é a /. Cada rota está atrelada a uma funcionalidade, ou seja, ao ser acessada, dispara uma
                    lógica.</p>

                <p><a href="#">GitHub - 6_EXPRESS\2-setup</a></p>

                <h3>Renderizando HTML</h3>

                <p>Para renderizar um html temos que passar o comando sendFile('documento com caminho completo')</p>

                <p><a href="#">GitHub - 6_EXPRESS\3-render-html</a></p>

                <h3>Nodemon - atualização automática</h3>

                <p>Esse módulo faz com que cada vez que salvarmos um documento e atualizarmos a página que está rodando
                    o projeto, essa atualização seja já renderizada no navegador, sem precisar matar o projeto e
                    reiniciá-lo para ver as alterações.</p>

                <p>O ideal é salvar esse pacote para o ambiente de desenvolvimento, portanto sua instalação ideal é
                    <b>npm i --save-dev nodemon</b></p>

                <p>Depois de instalar o nodemon, nós vamos no package.json e criamos o script start passando os
                    seguintes valores para ele <span style="color:orangered">"nodemon .index.js ((ou outro documento que
                        estejamos utilizando)) localhost 3000 ((ou outra porta que estivermos utilizando))"</span></p>

                <p>Desta forma o projeto será executado não mais utilizando o comando node index.js, mas sim o comando
                    <b>npm start</b></p>

                <p><a href="#">GitHub - 6_EXPRESS\4-nodemon</a></p>

                <h3>Middlewares</h3>

                <p>Códigos que podem ser executados entre uma ação e outra. Por exemplo, verificar se o usuário está
                    autenticado.</p>

                <p>Utilizamos o método <span style="color:green">use</span> do Express para utilizar middlewares.</p>

                <p>O método <span style="color:green">use</span> espera uma função que tem 3 parâmetro (requisição,
                    resposta, next) e a partir dela é feita a lógica de middleware</p>

                <p><a href="#">GitHub - 6_EXPRESS\5-middleware</a></p>

                <h3 id="">Parâmetros pela url</h3>

                <p>É possível recuperar e trabalhar com parâmetros passados pela url da requisição.</p>

                <p><a href="#">GitHub - 6_EXPRESS\6-params-url</a></p>

                <h3>Enviando dados pelo método POST</h3>

                <p>É um método de envio de dados de um formulário para um banco de dados através de uma lógica (action)
                    estabelecida em uma url.</p>

                <p><a href="#">GitHub - 6_EXPRESS\7-post-dados</a></p>

                <h3>Módulo de rotas</h3>

                <p>Nós podemos separar as rotas passadas pelo app.get e app.post tirando do documento de lógica
                    principal e colocar em uma pasta. Depois disso colocamos um middleware, a partir do app.use, para
                    ficar verificando a rota passada e ir para a pasta que controla essa rota.</p>

                <p>No arquivo de rotas nós temos que usar ao invés de app.get ou app.post router.get e router.post,
                    sendo esse router um método importado de express. Temos que no final do arquivo de rotas fazer a
                    exportação de router. É nessário também no arquivo de rotas atualizar o templatesPath.</p>

                <p>Para isso funcionar, temos que exportar as rotas do documento de rotas para o documento da aplicação
                    principal. </p>

                <p><a href="#">GitHub - 6_EXPRESS\8-modulo-rotas</a></p>

                <h3 id='express-css'>Colocando CSS</h3>

                <p>Para colocar os estilos css nós vamos colocar no arquivo principal da aplicação o comando
                    <b>app.use(express.static("path relativo da pasta que armazenará todas as pastas com documentos
                        estáticos, não apenas as folhas de estilo. Geralmente esta pasta é a ./public"))</b></p>

                <p>Já nos aquivos html que estivermos escrevendo, nós vamos chamar a folha de estilo através da tag link
                    e o href será passado como se já estivéssemos dentro da pasta que armazena os estáticos.</p>

                <p><a href="#">GitHub - 6_EXPRESS\9-css</a></p>

                <h2 id='template-engines'><span style="color:green"><i class="fab fa-node-js"></i> </span>Seção 7 -
                    Template Engines</h2>

                <h3>O que é Template Engine?</h3>

                <p>Template Engine (criador de template) é a definição de uma programação para definir o que será
                    exibido na view, ou seja, o que será construído no html</p>

                <p>Através dessa ferramenta nós podemos inserir variáveis do back no front. Essencial para projetos que
                    usam banco de dados (ou seja, que não são estáticos).</p>

                <p>Existem vários pacotes de programas para fazer o template engine.</p>

                <p>Nós vamos utilizar o Handlebars.</p>

                <h3>Handlebars</h3>

                <p>A filosifia desse pacote é colocar menos lógica de programação na view.</p>

                <p>Chaves duplas no html indica a utilização do Handlebars.</p>

                <p>É um módulo dentro do express, embora ele também é utilizado tanto em outras frames de js quanto em
                    outras linguagens.</p>

                <p>Para trabalhar com ele precisamos instalar o express e o handlebars através de <b>npm i express
                        express-handlebars</b>.</p>

                <p>Os arquivos que anteriormente eram .html agora são .handlebars com as mesmas tags e forma de escrever
                    um documento html</p>

                <p>Para utilizar o handlebars nós seguimos o padrão estabelecido em <a href="#">GitHub -
                        7_TEMPLATE_ENGINE\1-instalacao-handlebars</a></p>

                <h3>Criando layouts</h3>

                <p>Nesta etapa nós preparamos as páginas modelo (template) onde serão inseridos os dados dinamicamente.
                </p>

                <p>Para inserir os dados de um handlebars para o outro temos que utilizar no que vai receber os dados a
                    tag {{{body}}}</p>

                <p><a href="#">GitHub - 7_TEMPLATE_ENGINE\2-criando-layouts</a></p>

                <p><span style="color:red">OBS: a forma como estamos estruturando os diretórios no projeto do GitHub
                        estão seguindo o padrão handlebars, por isso não precisam de configurações especiais.</span></p>

                <h3>Passando dados para a view</h3>

                <p>Dentro do get nós podemos criar variáveis (ou receber dados do banco) que podem ser colocadas como
                    parâmetros do render e esses dados podem ser acessados na view de destino.</p>

                <p><a href="#">GitHub - 7_TEMPLATE_ENGINE\3-dados-view</a></p>

                <h3>Estruturas Condicionais</h3>

                <p>Nós podemos usar dentro do .handlebars o comando {{#if 'condição'}} programação da condição === true
                    {{/if}}</p>

                <p>Para usar o else damos {{#if 'condição'}} programação da condição === true {{else}} programação da
                    condição === false {{/if}}</p>

                <p><a href="#">GitHub - 7_TEMPLATE_ENGINE\4-if-else</a></p>

                <h3>Estruturas de repetição</h3>

                <p>Utilizamos o comando each para percorrer cada um dos itens de um array, sendo que cada item é
                    referenciado dentro da estrutura de repetição o comando this</p>

                <p>{{#each 'array'}}</p>
                <p>&nbsp;&nbsp;&nbsp;&nbsp;{{this}}</p>
                <p>{{/each}}</p>

                <p><a href="#">GitHub - 7_TEMPLATE_ENGINE\5-loop-each</a></p>

                <h3>Utilizando with</h3>

                <p>Simplifica a chamada de atributos de um objeto passado para o front.</p>

                <p>No exemplo de <a href="#">GitHub - 7_TEMPLATE_ENGINE\6-with</a> temos o objeto post que é exportado
                    para a página blogpost.handlebars e nela, com o with nós encapsulamos todos os atributos deste
                    objeto.</p>

                <p>{{#with 'objeto'}}</p>
                <p>&nbsp;&nbsp;&nbsp;&nbsp;{{'atributo'}}</p>
                <p>{{/with}}</p>

                <h3>Partials</h3>

                <p>Usado para criar como se fossem componentes de react.</p>

                <p><a href="#">GitHub - 7_TEMPLATE_ENGINE\7-partials</a></p>

                <h3>CSS com handlebars</h3>

                <p>Inicialmente é igual ao <a href="#express-css">CSS com Express</a>, porém neste caso nós vamos fazer
                    o link do css no views/layouts/main.handlebars.</p>

                <p><a href="#">GitHub - 7_TEMPLATE_ENGINE\8-css</a></p>

                <p>Neste caso todos os documentos serão afetados pelo css que está no main.handlebars, uma vez que todos
                    os conteúdos estão sendo renderizados nesta página.</p>

                <H2 id="node-mysql"><span style="color:green"><i class="fab fa-node-js"></i> </span>Seção 8 - Node.js e MySQL</H2>

                <h3>O que são bancos relacionais?</h3>

                <p>São estruturas para armazenamentos de dados que conversam entre si. Os bancos de dados relacionais
                    tem as seguintes entidades:</p>

                <ul>
                    <li>Bancos de dados: são conjuntos de tabelas</li>
                    <li>Tabelas: local onde armazenamos os dados</li>
                    <li>Colunas: separação categorizada dos dados</li>
                    <li>Dados: aquilo que é inserido, lido, modificado ou removido</li>
                    <li>Relacionamentos: ligações entre as tabelas</li>
                </ul>

                <h3>O que é o MySQL</h3>

                <p>É um sistema gerenciador de bancos de dados (SGBD). Ele nos ajuda a trabalhar com bancos de dados
                    relaionais. É o sgbd mais utilizado atualmente. Muitos projetos Node.js utilizam MySQL (alguns
                    utilizam bancos não relacionais (MongoDB)).</p>

                <H3>Instalação do MySQL no Windows</H3>

                <p style="background-color: yellow;color:red"> O professor usou o Xampp para trabalhar com o banco de
                    dados local, eu vou usar diretamente a configuração do MySQL. </p>
                <div class="inativo" style='border: red 1px solid'>
                    <p>Vai ser instalado com o XAMPP.</p>

                    <p>Para utilizá-lo nós temos que dar o start no painel do xampp</p>
                </div>


                <h3>Executando o MySQL pelo terminal</h3>
                <div class="inativo">
                    <p>Para conseguir executar o mysql no terminal nós temos que adicionar o caminho da pasta bin do
                        mysql do xampp no path das variáveis de ambiente.</p>

                    <p>Depois do processo de definir a variável de ambiente pode ser necessário reiniciar o pc.</p>

                    <p>Para confirmar se o mysql está ok nós temos que estar com o mysql startado no painel do xampp e
                        dar o comando <b>mysql -u root</b>, que faz o chamado do mysql com o usuário root, que é o
                        padrão criado pelo próprio programa. Esse comando gera uma mensagem de boas vindas do maria db.
                    </p>

                    <p>Para desconectar do banco damos o comando <b>exit</b></p>
                </div>
                <!--fim do inativo-->

                <p>Para usar o mysql no terminal nós temos que adicionar o caminho da pasta bin do server do mysql no
                    path das variáveis de ambiente. Depois disso, no terminal, damos o comando <b>mysql -h localhost -u
                        root -p</b> será solicitada a senha do nosso mysql e depois estaremos dentro.</p>

                <h3>Instalação no Linux</h3>

                <p>A instalação no linux é mais simples. Voltaremos novamente em outro momento para aprender.</p>

                <h3>Workbench</h3>

                <p>É um software da empresa MySQL (Oracle) que cria uma interface gráfica para trabalhar com o MySQL.
                </p>

                <p>Existem outras ferramentas, mas ele usará esta no curso.</p>

                <p>Temos que instalá-lo a partir do download do instalador na <a
                        href="https://dev.mysql.com/downloads/windows/installer/8.0.html">página do MySQL</a>. Foi
                    baixada a versão community (não a web-community).</p>

                <h3>HeidiSQL</h3>

                <P>No momento do curso, o HeidiSQL era uma alternativa ao Workbench. É só dar um google e baixar.</P>

                <h3>Conectando o Node ao MySQL</h3>

                <p>No workbench nós clicamos no botão de criação de banco (o símbolo do botão de criação do banco é
                    parecido com o seguinte: <i class="fas fa-database"></i>.</p>

                <p>Primeiramente temos que instalar o driver (pacote) do mysql através do npm, depois conectar o projeto
                    ao banco, passando o host, user, password e nome do banco.</p>

                <p><a href="#">GitHub - 8_MYSQL\1-instalacao-mysql</a></p>

                <H3>Criando uma tabela</H3>

                <p>Tabela é o local onde inserimos os dados e para manipulá-los. Faremos a manipulação e criação de
                    tabelas pelo workbech, mas também é possível fazer pela linha de código.</p>

                <p>Para criar uma tabela clicamos no botão ao lado do de criar um banco. Na página que segue vamos
                    criando os dados necessários.</p>

                <p>O id geralmente é a nossa primeira coluna. Colocamos a constraint primary key, auto increment e not
                    null para esta coluna.</p>

                <p>Nesta aula nós criamos uma tabela chamada books e nela nós colocamos as colunas id (INT), title
                    (VARCHAR(200)) e pageqty(INT)</p>

                <h3>Inserindo dados na tabela</h3>

                <p>Para inserir dados precisamos criar e executar uma query. Essa query é uma string que será criada
                    dentro do projeto node.</p>

                <p><a href="#">github - 8_MYSQL\2-inserindo-dados</a></p>

                <h3>Resgatando dados</h3>

                <p><a href="#">github - 8_MYSQL\3-lendo-dados</a></p>

                <h3>Editando dados</h3>

                <p><a href="#">GitHub - 8_MYSQL\4-edicao-dados</a></p>

                <h3>Excluindo dados</h3>

                <p><a href="#">GitHub - 8_MYSQL\5-deletando-dados</a></p>

                <h3>Connetion Pool</h3>

                <p>É um recursos para otimizar as conexões com o banco, criando um cache, que permite a consulta de
                    dados "mais recentes" sem a necessidade de ir no banco fazer as querys.</p>

                <p>O driver mysql que utilizamos aqui no node já tem esse recurso.</p>

                <p>Para usá-lo nos usamos o método mysql.createPool, passando os mesmos argumentos que createConnection
                    com a diferença que aqui também definimos um connectionLimit, que vai matar conexões inativas ou
                    desnecessárias mantendo apenas o número especificado de conexões.</p>

                <p>Esse recurso é importante para utilizar memória apenas nas ações necessárias evitando inclusive a
                    queda da aplicação.</p>

                <p>Ao usar o pool nós podemos descartar, portanto o createConnection e o connect realizado por ele, e
                    trocar os conn, adivindos do connect por pool.</p>

                <p><a href="#">GitHub - 8_MYSQL\6-connection-pool</a></p>

                <h3>Preparar query</h3>

                <p>Evita SQL Injection, nós vamos colocar duas interrogações nos nomes das colunas e uma interrogação no
                    valor do atributo do dado. Depois nós colocamos a ordem de substituição das interrogações em um
                    array e passamos esse array no método de query pro banco.</p>





                <div id="fim"></div>

                <div style="background-color:rgb(230, 248, 238);margin: 0;">
                    <h2 style="color:red">Aprofundar em:</h2>

                    <ul>
                        <li>
                            <a href="#template-engines">Template Engines</a>: Como utilizar mais de um layout?
                        </li>
                    </ul>
                </div>

    </main>
</div>